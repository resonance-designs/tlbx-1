import { Theme } from "../theme/index.slint";

/*
Component: RDSKnob
Description: A rotary knob component that supports both bounded and infinite rotation modes, with optimized rendering for different backends.
Public members:
- renderer: string - "lo-fi" (default) for software rendering or "hi-fi" for hardware rendering
    - IMPORTANT: This is dependent on your backend capabilities.
        - If you use "hi-fi" on a software backend, it will fallback to "lo-fi" and you may see the UI render differently than expected
- value: float - Current value
- rotation-angle: angle - Current rotation angle
- size: length - Size of the knob (width and height are bounded to this)
- indicator-position: length - Distance from center to indicator (radius)
- sensitivity: float - Adjust this to change rotation speed
- scroll-sensitivity: float - Sensitivity for mouse scroll wheel
- min-value: float - Minimum value (set equal to max-value for infinite mode - if not set, defaults to infinite)
- max-value: float - Maximum value (set equal to min-value for infinite mode - if not set, defaults to infinite)
- value-changed(float): callback - Triggered when the value changes via user interaction

Example usage:
- Basic bounded knob:
    RDSKnob {
        renderer: "hi-fi";
        size: 64px;
        indicator-position: 20px;
        min-value: 0;
        max-value: 1;
        value-changed(v) => { root.gain = v; }
    }
*/

export component RDSKnob inherits Rectangle {
    // Public properties
    in-out property <float> value: 0;
    property <angle> rotation-angle: root.is-infinite ? root.value * 1deg : -135deg + ((root.value - root.min-value) / Math.max(0.01, root.max-value - root.min-value)) * 270deg;
    in-out property <length> size: 60px;
    in-out property <length> indicator-position: 15px;
    in-out property <float> sensitivity: 0.5;
    in-out property <float> scroll-sensitivity: 1.0;

    in-out property <float> min-value: 0;
    in-out property <float> max-value: 0;

    callback value-changed(float);

    private property <length> drag-start-y: 0px;
    private property <float> drag-start-value: 0;
    private property <bool> is-infinite: root.min-value == root.max-value;

    width: root.size;
    height: root.size;
    background: transparent;

    Image {
        width: root.size;
        height: root.size;
        image-fit: contain;
        source: @image-url("../assets/knob_body.svg");
    }

    // Position/value indicator - size scales with knob size
    indicator := Image {
        width: root.size / 6;
        height: root.size / 6;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        image-fit: contain;
        source: @image-url("../assets/knob_indicator.svg");
    }

    // Touch area covers the entire component
    touch := TouchArea {
        pointer-event(event) => {
            if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                root.drag-start-y = self.mouse-y;
                root.drag-start-value = root.value;
            }
        }

        moved => {
            if (self.pressed) {
                root.value = root.drag-start-value + (root.drag-start-y - self.mouse-y) / 1px * root.sensitivity;
                if (!root.is-infinite) {
                    root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
                }
                root.value-changed(root.value);
            }
        }

        scroll-event(event) => {
            root.value = root.value - (event.delta-y / 1px) * root.scroll-sensitivity;
            if (!root.is-infinite) {
                root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
            }
            root.value-changed(root.value);
            return accept;
        }
    }
}

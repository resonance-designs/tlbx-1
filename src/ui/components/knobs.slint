import { Theme } from "../theme/index.slint";

/*
Component: RDSKnob
Description: A rotary knob component that supports both bounded and infinite rotation modes, with optimized rendering for different backends.
Public members:
- renderer: string - "hi-fi" (default) or "lo-fi"
- indicator: string - "circle" (default), "line", or "caret"
- indicator-color: color - color for indicators
- value: float - Current value
- rotation-angle: angle - Current rotation angle
- size: length - Size of the knob (width and height are bounded to this)
- indicator-position: length - Distance from center to indicator (radius)
- sensitivity: float - Adjust this to change rotation speed
- scroll-sensitivity: float - Sensitivity for mouse scroll wheel
- min-value: float - Minimum value (set equal to max-value for infinite mode - if not set, defaults to infinite)
- max-value: float - Maximum value (set equal to min-value for infinite mode - if not set, defaults to infinite)
- label: string - Text label for the knob
- label-pos: string - Position of the label ("top-left", "top-center", "top-right", "center-left", "center-center", "center-right", "bottom-left", "bottom-center", "bottom-right")
- label-width: length - Custom width for label area
- label-height: length - Custom height for label area
- label-txt-color: color - Color of the label text
- label-bg-color: color - Background color of the label area
- label-font-size: length - Font size for the label
- label-font-weight: int - Font weight for the label
- readout-enabled: bool - Show/hide the readout
- readout-text: string - Override text for the readout (defaults to value)
- readout-mode: string - "raw" | "percent" | "literal"
- readout-suffix: string - Optional suffix for raw mode (e.g., "Hz")
- readout-literals: [string] - Literal labels for "literal" mode
- readout-pos: string - Position of the readout ("top-left", "top-center", "top-right", "center-left", "center-center", "center-right", "bottom-left", "bottom-center", "bottom-right")
- readout-width: length - Custom width for readout area
- readout-height: length - Custom height for readout area
- readout-txt-color: color - Color of the readout text
- readout-bg-color: color - Background color of the readout area
- readout-font-size: length - Font size for the readout
- readout-font-weight: int - Font weight for the readout
- value-changed(float): callback - Triggered when the value changes via user interaction

Example usage:
- Basic bounded knob with label:
    RDSKnob {
        label: "Gain";
        size: 64px;
        indicator-position: 20px;
        min-value: 0;
        max-value: 1;
        value-changed(v) => { root.gain = v; }
    }
*/

export component RDSKnob inherits Rectangle {
    // Public properties
    in-out property <float> value: 0;
    property <angle> rotation-angle:
        (root.is-infinite || root.infinite-rotary)
            ? root.rotary-value * 1deg
            : -135deg + ((root.value - root.min-value) / Math.max(0.01, root.max-value - root.min-value)) * 270deg;
    in-out property <length> size: 60px;
    in-out property <length> indicator-position: 15px;
    in-out property <float> sensitivity: 0.5;
    in-out property <float> scroll-sensitivity: 1.0;
    in-out property <string> renderer: "hi-fi";
    in-out property <string> indicator: "circle";
    in-out property <color> indicator-color: #b9b9bf;
    in-out property <string> label: "";
    in-out property <length> label-width: root.size;
    in-out property <length> label-height: root.label-font-size + 8px;
    in-out property <color> label-txt-color: Theme.active.ui_label_txt;
    in-out property <color> label-bg-color: transparent;
    in-out property <length> label-font-size: 11px;
    in-out property <int> label-font-weight: 400;
    in-out property <string> label-pos: "bottom-center";
    in-out property <bool> readout-enabled: true;
    in-out property <string> readout-text: "";
    in-out property <string> readout-mode: "raw";
    in-out property <string> readout-suffix: "";
    in-out property <[string]> readout-literals: [];
    in-out property <string> readout-pos: "center-center";
    in-out property <length> readout-width: root.size;
    in-out property <length> readout-height: root.readout-font-size + 8px;
    in-out property <color> readout-txt-color: Theme.active.ui_label_txt;
    in-out property <color> readout-bg-color: transparent;
    in-out property <length> readout-font-size: 11px;
    in-out property <int> readout-font-weight: 400;

    in-out property <float> min-value: 0;
    in-out property <float> max-value: 0;
    in-out property <bool> infinite-rotary: false;

    callback value-changed(float);

    private property <length> drag-start-y: 0px;
    private property <float> drag-start-value: 0;
    private property <float> drag-start-rotary: 0;
    private property <bool> is-infinite: root.min-value == root.max-value;
    private property <float> rotary-value: root.value;

    private property <length> label-x:
        root.label-pos == "top-left" || root.label-pos == "center-left" || root.label-pos == "bottom-left"
            ? -root.label-width - 4px
            : (root.label-pos == "top-right" || root.label-pos == "center-right" || root.label-pos == "bottom-right"
                ? root.width + 4px
                : (root.width - root.label-width) / 2);
    private property <length> label-y:
        root.label-pos == "top-left" || root.label-pos == "top-center" || root.label-pos == "top-right"
            ? -root.label-height - 4px
            : (root.label-pos == "center-left" || root.label-pos == "center-center" || root.label-pos == "center-right"
                ? (root.height - root.label-height) / 2
                : root.height + 4px);
    private property <float> readout-value-trunc:
        root.value < 0
            ? Math.ceil(root.value * 100.0) / 100.0
            : Math.floor(root.value * 100.0) / 100.0;
    private property <float> readout-clamped: Math.max(0.0, Math.min(1.0, root.value));
    private property <float> readout-percent: Math.floor(root.readout-clamped * 100.0);
    private property <int> readout-literal-index:
        root.readout-literals.length > 0
            ? Math.round(root.readout-clamped * (root.readout-literals.length - 1))
            : 0;
    private property <string> readout-literal:
        root.readout-literals.length > 0
            ? root.readout-literals[root.readout-literal-index]
            : "";
    private property <string> readout-display:
        root.readout-text != ""
            ? root.readout-text
            : (root.readout-mode == "percent"
                ? (root.readout-percent + "%")
                : (root.readout-mode == "literal"
                    ? (root.readout-literal != "" ? root.readout-literal : root.readout-value-trunc)
                    : (root.readout-value-trunc + root.readout-suffix)));
    private property <length> readout-x:
        root.readout-pos == "top-left" || root.readout-pos == "center-left" || root.readout-pos == "bottom-left"
            ? -root.readout-width - 4px
            : (root.readout-pos == "top-right" || root.readout-pos == "center-right" || root.readout-pos == "bottom-right"
                ? root.width + 4px
                : (root.width - root.readout-width) / 2);
    private property <length> readout-y:
        root.readout-pos == "top-left" || root.readout-pos == "top-center" || root.readout-pos == "top-right"
            ? -root.readout-height - 4px
            : (root.readout-pos == "center-left" || root.readout-pos == "center-center" || root.readout-pos == "center-right"
                ? (root.height - root.readout-height) / 2
                : root.height + 4px);

    width: root.size;
    height: root.size;
    background: transparent;

    Rectangle {
        visible: root.renderer == "lo-fi";
        width: root.size;
        height: root.size;
        background: #1c1c22;
        border-radius: root.size / 2;
        border-width: 2px;
        border-color: #2f2f3a;
    }

    Image {
        visible: root.renderer != "lo-fi";
        width: root.size;
        height: root.size;
        image-fit: contain;
        source: Theme.active.knob_body_svg;
    }

    Rectangle {
        visible: root.label != "";
        x: root.label-x;
        y: root.label-y;
        width: root.label-width;
        height: root.label-height;
        background: root.label-bg-color;
        Text {
            text: root.label;
            color: root.label-txt-color;
            font-size: root.label-font-size;
            font-weight: root.label-font-weight;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    Rectangle {
        visible: root.readout-enabled;
        x: root.readout-x;
        y: root.readout-y;
        width: root.readout-width;
        height: root.readout-height;
        background: root.readout-bg-color;
        Text {
            text: root.readout-display;
            color: root.readout-txt-color;
            font-size: root.readout-font-size;
            font-weight: root.readout-font-weight;
            horizontal-alignment: center;
            vertical-alignment: center;
        }
    }

    // Position/value indicator - size scales with knob size
    indicator_node := Rectangle {
        visible: root.renderer == "lo-fi" && root.indicator == "circle";
        width: root.size / 6;
        height: root.size / 6;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: root.indicator-color;
        border-radius: self.width / 2;
        border-width: 1px;
        border-color: #0e0e12;
    }

    Rectangle {
        visible: root.indicator == "line" && (root.renderer == "lo-fi" || root.renderer == "hi-fi");
        width: 2px;
        height: root.size / 4;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: root.indicator-color;
        border-radius: 1px;
    }

    Path {
        visible: root.indicator == "caret" && (root.renderer == "lo-fi" || root.renderer == "hi-fi");
        width: root.size / 5;
        height: root.size / 5;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        fill: root.indicator-color;
        commands: "M 0 0 L 1 0 L 0.5 1 Z";
    }

    Image {
        visible: root.renderer != "lo-fi" && root.indicator == "circle";
        width: root.size / 6;
        height: root.size / 6;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        image-fit: contain;
        source: Theme.active.knob_indicator_svg;
    }

    // Touch area covers the entire component
    touch := TouchArea {
        pointer-event(event) => {
            if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                root.drag-start-y = self.mouse-y;
                root.drag-start-value = root.value;
                root.drag-start-rotary = root.rotary-value;
            }
        }

        moved => {
            if (self.pressed) {
                let delta = (root.drag-start-y - self.mouse-y) / 1px * root.sensitivity;
                if (root.is-infinite || root.infinite-rotary) {
                    root.rotary-value = root.drag-start-rotary + delta;
                }
                if (root.is-infinite) {
                    root.value = root.rotary-value;
                } else {
                    root.value = root.drag-start-value + delta;
                    root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
                }
                root.value-changed(root.value);
            }
        }

        scroll-event(event) => {
            let delta = -(event.delta-y / 1px) * root.scroll-sensitivity;
            if (root.is-infinite || root.infinite-rotary) {
                root.rotary-value = root.rotary-value + delta;
            }
            if (root.is-infinite) {
                root.value = root.rotary-value;
            } else {
                root.value = root.value + delta;
                root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
            }
            root.value-changed(root.value);
            return accept;
        }
    }
}

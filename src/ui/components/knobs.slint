import { Theme } from "../theme/index.slint";

/*
Component: RDSKnob
Description: A rotary knob component that supports both bounded and infinite rotation modes, with optimized rendering for different backends.
Public members:
- renderer: string - "hi-fi" (default) or "lo-fi"
- indicator: string - "circle" (default), "line", or "caret"
- indicator-color: color - color for lo-fi indicators
- value: float - Current value
- rotation-angle: angle - Current rotation angle
- size: length - Size of the knob (width and height are bounded to this)
- indicator-position: length - Distance from center to indicator (radius)
- sensitivity: float - Adjust this to change rotation speed
- scroll-sensitivity: float - Sensitivity for mouse scroll wheel
- min-value: float - Minimum value (set equal to max-value for infinite mode - if not set, defaults to infinite)
- max-value: float - Maximum value (set equal to min-value for infinite mode - if not set, defaults to infinite)
- value-changed(float): callback - Triggered when the value changes via user interaction

Example usage:
- Basic bounded knob:
    RDSKnob {
        size: 64px;
        indicator-position: 20px;
        min-value: 0;
        max-value: 1;
        value-changed(v) => { root.gain = v; }
    }
*/

export component RDSKnob inherits Rectangle {
    // Public properties
    in-out property <float> value: 0;
    property <angle> rotation-angle: root.is-infinite ? root.value * 1deg : -135deg + ((root.value - root.min-value) / Math.max(0.01, root.max-value - root.min-value)) * 270deg;
    in-out property <length> size: 60px;
    in-out property <length> indicator-position: 15px;
    in-out property <float> sensitivity: 0.5;
    in-out property <float> scroll-sensitivity: 1.0;
    in-out property <string> renderer: "hi-fi";
    in-out property <string> indicator: "circle";
    in-out property <color> indicator-color: #b9b9bf;

    in-out property <float> min-value: 0;
    in-out property <float> max-value: 0;

    callback value-changed(float);

    private property <length> drag-start-y: 0px;
    private property <float> drag-start-value: 0;
    private property <bool> is-infinite: root.min-value == root.max-value;

    width: root.size;
    height: root.size;
    background: transparent;

    Rectangle {
        visible: root.renderer == "lo-fi";
        width: root.size;
        height: root.size;
        background: #1c1c22;
        border-radius: root.size / 2;
        border-width: 2px;
        border-color: #2f2f3a;
    }

    Image {
        visible: root.renderer != "lo-fi";
        width: root.size;
        height: root.size;
        image-fit: contain;
        source: @image-url("../assets/svg/knob_body.svg");
    }

    // Position/value indicator - size scales with knob size
    indicator_node := Rectangle {
        visible: root.renderer == "lo-fi" && root.indicator == "circle";
        width: root.size / 6;
        height: root.size / 6;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: root.indicator-color;
        border-radius: self.width / 2;
        border-width: 1px;
        border-color: #0e0e12;
    }

    Rectangle {
        visible: root.indicator == "line" && (root.renderer == "lo-fi" || root.renderer == "hi-fi");
        width: 2px;
        height: root.size / 4;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        background: root.indicator-color;
        border-radius: 1px;
    }

    Path {
        visible: root.indicator == "caret" && (root.renderer == "lo-fi" || root.renderer == "hi-fi");
        width: root.size / 5;
        height: root.size / 5;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        fill: root.indicator-color;
        commands: "M 0 0 L 1 0 L 0.5 1 Z";
    }

    Image {
        visible: root.renderer != "lo-fi" && root.indicator == "circle";
        width: root.size / 6;
        height: root.size / 6;
        x: root.width / 2 - self.width / 2 + Math.cos(root.rotation-angle - 90deg) * root.indicator-position;
        y: root.height / 2 - self.height / 2 + Math.sin(root.rotation-angle - 90deg) * root.indicator-position;
        image-fit: contain;
        source: @image-url("../assets/svg/knob_indicator.svg");
    }

    // Touch area covers the entire component
    touch := TouchArea {
        pointer-event(event) => {
            if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                root.drag-start-y = self.mouse-y;
                root.drag-start-value = root.value;
            }
        }

        moved => {
            if (self.pressed) {
                root.value = root.drag-start-value + (root.drag-start-y - self.mouse-y) / 1px * root.sensitivity;
                if (!root.is-infinite) {
                    root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
                }
                root.value-changed(root.value);
            }
        }

        scroll-event(event) => {
            root.value = root.value - (event.delta-y / 1px) * root.scroll-sensitivity;
            if (!root.is-infinite) {
                root.value = Math.max(root.min-value, Math.min(root.max-value, root.value));
            }
            root.value-changed(root.value);
            return accept;
        }
    }
}
